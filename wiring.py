#!/usr/bin/python3

from graphviz import Graph
from pathlib import Path
from strictyaml import load, Map, Str, Int, Seq, YAMLError, Optional
import argparse
import os
import sys

__version__ = '0.2'

title_color = 'lightblue'

def main():
    args = parse_args()

    if not os.path.exists(args.input_file):
        print(f'Error: input file {args.input_file} inaccessible or does not exist, check path')
        sys.exit(1)

    output_pre, output_ext = os.path.splitext(args.output_file)

    formats = [".png", ".svg", ".pdf"]

    if output_ext not in formats:
        print(f'Error: output file extension must be one of: {formats}, got {output_ext}')
        sys.exit(1)

    stream = open(args.input_file, 'r')

    schema = Map({
        "devices": Seq(
            Map({
                "name": Str(),
                Optional("pins"): Seq(Str()),
                Optional("type"): Str(),
                Optional("info"): Str()
            })
        ),
        Optional("connections"): Seq(
            Map({
                "from": Str(),
                "to": Str(),
                Optional("color", default="black"): Str(),
                Optional("group"): Str()
            })
        )
    })

    # docs = safe_load_all(stream)
    doc = Doc(load(stream.read(), schema))

    dot = Graph()

    font = "Roboto"

    # graph.body.append(f'// Graph generated by APP_NAME {__version__}\n')
    # graph.body.append(f'// APP_URL\n')
    dot.attr('graph',
        rankdir='LR',
        ranksep='2',
        bgcolor="#CCCCCC",
        nodesep='0.33',
        fontname=font)
    dot.attr('node',
        shape='box',
        width='0', height='0', margin='0',  # Actual size of the node is entirely determined by the label.
        style='filled',
        fillcolor='#F0F0F0',
        fontname=font)
    dot.attr('edge',
        style='bold',
        fontname=font)

    # dot.attr(splines='polyline')

    def create_table(device):
        table = '<<table border="1" cellspacing="0" cellpadding="2">'
        table += f'<tr><td colspan="2" bgcolor="{title_color}">{device.name}</td></tr>'

        fmt = '<tr><td port="{1}w">{0}</td><td port="{1}e">{1}</td></tr>'

        for i in range(len(device.pins)):
            table += fmt.format(i + 1, device.pins[i])

        table += '</table>>'

        return table

    for device in doc.devices.values():
        dot.node(device.name, label=create_table(device), shape='plaintext')

    for connection in doc.connections:
        if len(connection.fromPins) != len(connection.toPins):
            if len(connection.fromPins) == 0 and len(doc.devices[connection.fromDevice].pins) != 0:
                print(f"Error: in connection {connection.fromDevice}:{connection.fromPins} -> {connection.toDevice}:{connection.toPins} pin not specified but device {connection.fromDevice} has pins")
                exit(-1)

            if len(connection.toPins) == 0 and len(doc.devices[connection.toDevice].pins) != 0:
                print(f"Error: in connection {connection.fromDevice}:{connection.fromPins} -> {connection.toDevice}:{connection.toPins} pin not specified but device {connection.toDevice} has pins")
                exit(-1)

            if len(connection.fromPins) != 0 and len(connection.toPins) != 0:
                print(f"Error: connection {connection.fromDevice}:{connection.fromPins} -> {connection.toDevice}:{connection.toPins} has different number of from/to pins")
                exit(-1)

        for pin in connection.fromPins:
            if pin not in doc.devices[connection.fromDevice].pins:
                print(f"Error: pin {pin} not found in device {connection.fromDevice}")
                exit(-1)

        for pin in connection.toPins:
            if pin not in doc.devices[connection.toDevice].pins:
                print(f"Error: pin {pin} not found in device {connection.toDevice}")
                exit(-1)

        r = max(len(connection.fromPins), len(connection.toPins), 1)

        for i in range(r):
            if connection.fromPins:
                a = f"{connection.fromDevice}:{connection.fromPins[i]}e:e"
            else:
                a = f"{connection.fromDevice}:e"

            if connection.toPins:
                b = f"{connection.toDevice}:{connection.toPins[i]}w:w"
            else:
                b = f"{connection.toDevice}:w"

            dot.edge(a, b, color=connection.colors[i])

    dot.format = output_ext[1:]

    dot.render(filename=output_pre, view=args.show, cleanup=True)

def parse_args():
    parser = argparse.ArgumentParser(description='Generate cable and wiring harness documentation from YAML descriptions')
    parser.add_argument('-V', '--version', action='version', version='%(prog)s ' + __version__)
    parser.add_argument('input_file', action='store', type=str, metavar='YAML_FILE')
    # parser.add_argument('-o', '--output_file', action='store', type=str, metavar='OUTPUT')
    # make arg --output_file required:
    parser.add_argument('-o', '--output_file', action='store', type=str, metavar='OUTPUT', required=True)
    parser.add_argument('-s', '--show', action='store_true', default=False)
    # parser.add_argument('-d', '--dict', action='store_true', default=False)
    # Not implemented: parser.add_argument('--generate-bom', action='store_true', default=True)
    # parser.add_argument('--prepend-file', action='store', type=str, metavar='YAML_FILE')

    args = parser.parse_args()

    args.input_file = os.path.abspath(args.input_file)
    args.output_file = os.path.abspath(args.output_file)

    return args

class Doc:
    def __init__(self, yaml):
        self.devices = {}

        for device in yaml["devices"]:
            self.devices[device["name"].data] = Device(device)

        self.connections = [Connection(connection) for connection in yaml["connections"]]

class Device:
    def __init__(self, yaml):
        self.name = yaml["name"].data
        self.pins = yaml["pins"].data if "pins" in yaml else []
        self.type = yaml["type"].data if "type" in yaml else ""
        self.info = yaml["info"].data if "info" in yaml else ""

class Connection:
    def __init__(self, yaml):
        self.fromDevice, self.fromPins = self.getDeviceAndPins(yaml["from"].data)
        self.toDevice, self.toPins = self.getDeviceAndPins(yaml["to"].data)
        self.colors = self.getColors(yaml["color"].data) if "color" in yaml else ["black"]

    def getDeviceAndPins(self, from_):
        fromDevice, fromPin = from_.split(".") if "." in from_ else (from_, None)
        fromDevice = fromDevice.strip()
        if fromPin is not None:
            fromPin = fromPin.strip()

        fromPins = []

        if fromPin is not None:
            fromPins = [fromPin]

            if fromPin[0] == '{':
                if fromPin[-1] == '}':
                    fromPins = fromPin.split("{")[1].split("}")[0].split(",")
                else:
                    print(f"Error: malformed pin {fromPin}")
                    exit(-1)

        if fromPins is not None:
            fromPins = [pin.strip() for pin in fromPins]

        return fromDevice, fromPins

    def getColors(self, s):
        colors = {'RD': 'red', 'BL': 'blue', 'BK': 'black', 'GN': 'green', 'YL': 'yellow', 'OR': 'orange', 'GR': 'gray', 'WT': 'white', 'WH': 'white', 'BU': 'blue'}

        return [(colors[c] if c in colors else c) for c in s.split(",")]

if __name__ == '__main__':
    main()
