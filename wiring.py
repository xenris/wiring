#!/usr/bin/python3

from graphviz import Graph
from pathlib import Path
import argparse
import os
import sys
import yaml

__version__ = '0.1'

title_color = 'lightblue'

def main():
    args = parse_args()

    if not os.path.exists(args.input_file):
        print(f'Error: input file {args.input_file} inaccessible or does not exist, check path')
        sys.exit(1)

    output_pre, output_ext = os.path.splitext(args.output_file)

    formats = [".png", ".svg", ".pdf"]

    if output_ext not in formats:
        print(f'Error: output file extension must be one of: {formats}, got {output_ext}')
        sys.exit(1)

    stream = open(args.input_file, 'r')

    # docs = yaml.safe_load_all(stream)
    doc = yaml.safe_load(stream)

    # if args.dict:
    #     # for doc in docs:
    #     print(doc)
    #     exit()

    # success = True

    # if "devices" not in doc:
    #     print("Warning: Missing key 'devices'")
    #     # success = False

    # if "connections" not in doc:
    #     print("Warning: Missing key 'connections'")
    #     # success = False

    for key in doc.keys():
        if key not in ["devices", "connections", "wires"]:
            print("Warning: Unknown key: {}".format(key))
            # success = False

    # if not success:
    #     exit(-1)

    devices = doc["devices"]
    connections = doc["connections"]

    # engines = ["dot", "neato", "twopi", "circo", "fdp", "sfdp", "patchwork", "osage"]

    # dot = Graph(comment='a comment', engine=engines[0])
    dot = Graph()
    # graph = Digraph()

    # Set the background color of the graph
    # dot.graph_attr['bgcolor'] = 'transparent'

    font = "Roboto"

    shapes = ["box", "polygon", "ellipse", "oval", "circle", "point", "egg", "triangle", "plaintext", "plain", "diamond", "trapezium", "parallelogram", "house", "pentagon", "hexagon", "septagon", "octagon", "doublecircle", "doubleoctagon", "tripleoctagon", "invtriangle", "invtrapezium", "invhouse", "Mdiamond", "Msquare", "Mcircle", "rect", "rectangle", "square", "star", "none", "underline", "cylinder", "note", "tab", "folder", "box3d", "component", "promoter", "cds", "terminator", "utr", "primersite", "restrictionsite", "fivepoverhang", "threepoverhang", "noverhang", "assembly", "signature", "insulator", "ribosite", "rnastab", "proteasesite", "proteinstab", "rpromoter", "rarrow", "larrow", "lpromoter"]

    # graph.body.append(f'// Graph generated by APP_NAME {__version__}\n')
    # graph.body.append(f'// APP_URL\n')
    dot.attr('graph',
        rankdir='LR',
        ranksep='2',
        bgcolor="#CCCCCC",
        nodesep='0.33',
        fontname=font)
    dot.attr('node',
        shape=shapes[0],
        width='0', height='0', margin='0',  # Actual size of the node is entirely determined by the label.
        style='filled',
        fillcolor='#F0F0F0',
        fontname=font)
    dot.attr('edge',
        style='bold',
        fontname=font)

    # dot.attr(splines='polyline')

    def create_table(name, pins):
        table = '<<table border="1" cellspacing="0" cellpadding="2">'
        table += f'<tr><td colspan="2" bgcolor="{title_color}">{name}</td></tr>'

        fmt = '<tr><td port="{1}w">{0}</td><td port="{1}e">{1}</td></tr>'

        for i in range(len(pins)):
            table += fmt.format(i + 1, pins[i])

        table += '</table>>'

        return table

    for device in devices.items():
        # print(device)
        name = device[0]
        if "pins" not in device[1]:
            print("Warning: Missing key 'pins' in device: {}".format(device))
            continue
        pins = device[1]["pins"]

        dot.node(name, label=create_table(name, pins), shape='plaintext')

    for connection in connections:
        if len(connection) < 2 or len(connection) > 3:
            print("Warning: Invalid connection: {}".format(connection))
            continue

        a = connection[0]
        b = connection[1]
        c = connection[2] if len(connection) == 3 else None

        if not (isinstance(a, dict) and isinstance(b, dict) and (c is None or isinstance(c, dict))):
            print("Warning: Invalid connection: {}".format(connection))
            continue

        a1,a2 = tuple(a.items())[0]
        b1,b2 = tuple(b.items())[0]

        simple_left = False
        simple_right = False

        if a2 is None or a1 not in devices:
            # print("Warning: Unknown device: {}".format(a1))
            dot.node(a1, label=a1, shape='box')
            simple_left = True

        if b2 is None or b1 not in devices:
            # print("Warning: Unknown device: {}".format(b1))
            dot.node(b1, label=b1, shape='box', fillcolor=title_color)
            simple_right = True

        if not simple_right and not simple_left and len(a2) != len(b2):
            print("Warning: Invalid connection: {}".format(connection))
            continue

        colors = {'RD': 'red', 'BL': 'blue', 'BK': 'black', 'GN': 'green', 'YL': 'yellow', 'OR': 'orange', 'GR': 'gray', 'WT': 'white', 'WH': 'white', 'BU': 'blue'}

        for i in range(len(a2)):
            if 'wire' not in c:
                print("Warning: Missing key 'wire' in connection: {}".format(connection))
                continue
            code = c['wire'][i] if c is not None else 'black'
            color = colors[code] if code in colors else code
            # dot.edge(f'{a1}:{a2[i]}e:e', f'{b1}:{b2[i]}w:w', label=None, color=f'black:{colors[code]}:black', penwidth='2')
            if simple_left and simple_right:
                dot.edge(f'{a1}:e', f'{b1}:w', label=None, color=color, penwidth='2')
            elif simple_left:
                dot.edge(f'{a1}:e', f'{b1}:{b2[i]}w:w', label=None, color=color, penwidth='2')
            elif simple_right:
                dot.edge(f'{a1}:{a2[i]}e:e', f'{b1}:w', label=None, color=color, penwidth='2')
            else:
                dot.edge(f'{a1}:{a2[i]}e:e', f'{b1}:{b2[i]}w:w', label=None, color=color, penwidth='2')

    dot.format = output_ext[1:]

    dot.render(filename=output_pre, view=args.show, cleanup=True)

def parse_args():
    parser = argparse.ArgumentParser(description='Generate cable and wiring harness documentation from YAML descriptions')
    parser.add_argument('-V', '--version', action='version', version='%(prog)s ' + __version__)
    parser.add_argument('input_file', action='store', type=str, metavar='YAML_FILE')
    # parser.add_argument('-o', '--output_file', action='store', type=str, metavar='OUTPUT')
    # make arg --output_file required:
    parser.add_argument('-o', '--output_file', action='store', type=str, metavar='OUTPUT', required=True)
    parser.add_argument('-s', '--show', action='store_true', default=False)
    # parser.add_argument('-d', '--dict', action='store_true', default=False)
    # Not implemented: parser.add_argument('--generate-bom', action='store_true', default=True)
    # parser.add_argument('--prepend-file', action='store', type=str, metavar='YAML_FILE')

    args = parser.parse_args()

    args.input_file = os.path.abspath(args.input_file)
    args.output_file = os.path.abspath(args.output_file)

    # print(args.input_file, args.output_file)

    return args

if __name__ == '__main__':
    main()
